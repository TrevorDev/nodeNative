#hdr

#include "vulkan/vulkan.h"//
#include <stdio.h>
#include <stdlib.h>
#define _alloca __builtin_alloca
#define BAIL_ON_BAD_RESULT(result) if (VK_SUCCESS != (result)) { fprintf(stderr, "Failure at %u %s\n", __LINE__, __FILE__); exit(-1); }
#end



class VulkanHelper
{
public:
	VkInstance instance;
	VkPhysicalDevice defaultPhysicalDevice;
	VkDevice device;
	int num;

	VulkanHelper(void) {
		this->num = 5;

		//Vulcan init config
		const VkApplicationInfo applicationInfo = {
			VK_STRUCTURE_TYPE_APPLICATION_INFO,
			0,
			"VKComputeSample",
			0,
			"",
			0,
			VK_MAKE_VERSION(1, 0, 9)
		};
		const VkInstanceCreateInfo instanceCreateInfo = {
			VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
			0,
			0,
			&applicationInfo,
			0,
			0,
			0,
			0
		};

		//Init Vulkan
		BAIL_ON_BAD_RESULT(vkCreateInstance(&instanceCreateInfo, 0, &this->instance));
	};

	void initDevice() {
		//Get default device
		uint32_t physicalDeviceCount = 0;
		BAIL_ON_BAD_RESULT(vkEnumeratePhysicalDevices(this->instance, &physicalDeviceCount, 0));
		VkPhysicalDevice* const physicalDevices = (VkPhysicalDevice*)malloc(sizeof(VkPhysicalDevice) * physicalDeviceCount);
		BAIL_ON_BAD_RESULT(vkEnumeratePhysicalDevices(this->instance, &physicalDeviceCount, physicalDevices));
		this->defaultPhysicalDevice = physicalDevices[0];

		//Get device initialization config
		uint32_t queueFamilyIndex = 0;
		BAIL_ON_BAD_RESULT(VulkanHelper::vkGetBestComputeQueueNPH(defaultPhysicalDevice, &queueFamilyIndex));
		const float queuePrioritory = 1.0f;
		const VkDeviceQueueCreateInfo deviceQueueCreateInfo = {
			VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
			0,
			0,
			queueFamilyIndex,
			1,
			&queuePrioritory
		};
		const VkDeviceCreateInfo deviceCreateInfo = {
			VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
			0,
			0,
			1,
			&deviceQueueCreateInfo,
			0,
			0,
			0,
			0,
			0
		};

		//Initialize logical device
		BAIL_ON_BAD_RESULT(vkCreateDevice(defaultPhysicalDevice, &deviceCreateInfo, 0, &this->device));
	};

	void allocGPUMemory(uint32_t bufferSize) {
		VkPhysicalDeviceMemoryProperties properties;

		vkGetPhysicalDeviceMemoryProperties(this->defaultPhysicalDevice, &properties);

		// const int32_t bufferLength = 16384;

		// const uint32_t bufferSize = sizeof(int32_t) * bufferLength;

		// we are going to need two buffers from this one memory
		const VkDeviceSize memorySize = bufferSize * 2;

		// set memoryTypeIndex to an invalid entry in the properties.memoryTypes array
		uint32_t memoryTypeIndex = VK_MAX_MEMORY_TYPES;

		for (uint32_t k = 0; k < properties.memoryTypeCount; k++) {
			if ((VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT & properties.memoryTypes[k].propertyFlags) &&
			        (VK_MEMORY_PROPERTY_HOST_COHERENT_BIT & properties.memoryTypes[k].propertyFlags) &&
			        (memorySize < properties.memoryHeaps[properties.memoryTypes[k].heapIndex].size)) {
				memoryTypeIndex = k;
				break;
			}
		}

		BAIL_ON_BAD_RESULT(memoryTypeIndex == VK_MAX_MEMORY_TYPES ? VK_ERROR_OUT_OF_HOST_MEMORY : VK_SUCCESS);

		const VkMemoryAllocateInfo memoryAllocateInfo = {
			VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
			0,
			memorySize,
			memoryTypeIndex
		};
		
		VkDeviceMemory memory;
    	BAIL_ON_BAD_RESULT(vkAllocateMemory(device, &memoryAllocateInfo, 0, &memory));
	}

	int getNum() {
		return this->num;
	}
	static double version () { return 0.1; };


	static VkResult vkGetBestComputeQueueNPH(VkPhysicalDevice physicalDevice, uint32_t* queueFamilyIndex) {
		uint32_t queueFamilyPropertiesCount = 0;
		vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyPropertiesCount, 0);

		VkQueueFamilyProperties* const queueFamilyProperties = (VkQueueFamilyProperties*)_alloca(sizeof(VkQueueFamilyProperties) * queueFamilyPropertiesCount);

		vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyPropertiesCount, queueFamilyProperties);

		// first try and find a queue that has just the compute bit set
		for (uint32_t i = 0; i < queueFamilyPropertiesCount; i++) {
			// mask out the sparse binding bit that we aren't caring about (yet!) and the transfer bit
			const VkQueueFlags maskedFlags = (~(VK_QUEUE_TRANSFER_BIT | VK_QUEUE_SPARSE_BINDING_BIT) &
			                                  queueFamilyProperties[i].queueFlags);

			if (!(VK_QUEUE_GRAPHICS_BIT & maskedFlags) && (VK_QUEUE_COMPUTE_BIT & maskedFlags)) {
				*queueFamilyIndex = i;
				return VK_SUCCESS;
			}
		}

		// lastly get any queue that'll work for us
		for (uint32_t i = 0; i < queueFamilyPropertiesCount; i++) {
			// mask out the sparse binding bit that we aren't caring about (yet!) and the transfer bit
			const VkQueueFlags maskedFlags = (~(VK_QUEUE_TRANSFER_BIT | VK_QUEUE_SPARSE_BINDING_BIT) &
			                                  queueFamilyProperties[i].queueFlags);

			if (VK_QUEUE_COMPUTE_BIT & maskedFlags) {
				*queueFamilyIndex = i;
				return VK_SUCCESS;
			}
		}

		return VK_ERROR_INITIALIZATION_FAILED;
	}

};